<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8' />
		<meta http-equiv="X-UA-Compatible" content="chrome=1" />
		<meta name="description" content="NICTA SmartGridToolbox : Microgrid tutorial" />
		<link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
		<title>NICTA SmartGridToolbox Architecture</title>
	</head>
	<body>
	<!-- MAIN CONTENT -->
		<div id="main_content_wrap" class="outer">
			<section id="main_content" class="inner">
				<p>
					<img src="images/logo.png?raw=true" alt="SmartGridToolbox Logo">
				</p>
				<h3><a name="sgt-architecture" class="anchor" href="#sgt-architecture"></a>Introduction to the SmartGridToolbox Architecture</h3>
				<p>
					SmartGridToolbox is a library that can be used to rapidly develop simulations of of smart grid and microgrid systems. It is written in C++11, and users will need access to a compiler that can handle this C++ specification.
				</p>
				<h4><a name="sgt-libraries" class="anchor" href="#sgt-libraries"></a>SmartGridToolbox Libraries</h4>
				<p>
					SmartGridToolbox consists of two libraries: <strong>SgtCore</strong> , which contains core utilities and powerflow modelling tools and solvers, and <strong>SgtSim</strong>, which contains the simulation architecture and simulation components. SgtCore may be used in a standalone manner, for non-simulation based tasks. SgtSim is built on top of SgtCore. In the following, we will assume that SmartGridToolbox has already been compiled and installed in the default location, <code>/usr/local</code>.
				</p>
				<h5><a name="sgt-libraries-including" class="anchor" href="#sgt-libraries-including"></a>Including and linking the SmartGridToolbox libraries</h5>
				<p>
					SmartGridToolbox programs will need to link to the SmartGridToolbox libraries, and will need to include the relevant SmartGridToolbox header files.
				</p>
				<p>
					Header files may be included individually, as follows, e.g.:
<script type="text/html" class="code">#include <SgtCore/Network.h>
#include <SgtSim/Simulation.h></script>
					or they may be all included automatically using 
<script type="text/html" class="code">#include <SgtCore.h>
#include <SgtSim.h>
</script>
				</p>
				<p>
					SmartGridToolbox uses the GNU autotools build system, and builds libraries using libtool. By default, static libraries only are built; for dynamic libraries, SmartGridToolbox should be <code>configure</code>d with the <code>--enable-shared</code> option.
				</p>
				<p>
					The easiest cross-platform way to link to your application is to also use libtool with the GNU autotools. <code>SmartGridToolbox/tutorials/Simulation/Makefile.am</code> gives an example of how to do this. Libtool handles all library dependencies, and correctly handles shared libraries in a manner that is appropriate for the architecture.
				</p>
				<p>
					Otherwise, you must choose	the correct static and dynamic libraries. To statically link a program, the following link flags will work: <code>-lSgtCore -lSgtSim -larmadillo -lboost_date_time -lyaml-cpp</code>. If your program is using <code>SgtCore</code> only, then obviously the <code>-lSgtSim</code> flag should be omitted.
				</p>
				<h4><a name="sgt-utsl" class="anchor" href="#sgt-utsl"></a>Use the Source, Luke</h4>
				<p>
					At present, the SmartGridToolbox documentation is somewhat sketchy. Users are encouraged to explore the source code, either directly, or through the <a href="doxygen_docs/index.html">doxygen documentation</a> (organised by functional modules <a href="doxygen_docs/modules.html">here</a>).
				</p>
				In terms of the SmartGridToolbox directory structure, core and non-simulation functionalities are located in the <code>SgtCore</code> subdirectory and the simulation engine and components are located in <code>SgtSim</code>. The <code>src</code> directory contains the source code for simple applications (providing a good reference for how to use the SmartGridToolbox library. <code>test</code> provides unit tests, which can also be a good reference. <code>tutorials</code> contains annotated <a href="#tutorials">tutorials</a>, and <code>examples</code> contains more developed examples, which give a sample of how SmartGridToolbox can be used.
				</p>
				<h4><a name="sgt-foundation" class="anchor" href="#sgt-foundation"></a>SmartGridToolbox Foundation Classes and Functions</h4>
				<h5><a name="sgt-component" class="anchor" href="#sgt-component"></a>The Component class</h5>
				<p>
					Most objects in SmartGridToolbox models and simulations derive from the <code><a href="doxygen_docs/class_sgt_1_1_component.html">Component</a></code> class. The most important function of this class is to provide a unique key (a <code>std::string</code>) for each object. <code>Component</code>s are also able to provide a component type string, to print themselves, and to act as an access point to an objects <code>Property</code>s.
				</p>
				<p>
					For classes that directly derive from <code>Component</code>, it is normally best to use virtual inheritance. For example:
					<pre><code>class ZipAbc : virtual public Component</code></pre>
				</p>
				<p>
					This has to do with the possibility multiple inheritance in SmartGridToolbox. Multiple inheritance is a contentious issue in C++, and, indeed, object-oriented languages in general. Although it is often best to avoid multiple inheritance altogether, or to severely restrict its use, SmartGridToolbox <a href=#sgt-mult>does, in a couple of very restricted situations, use multiple inheritance</a>, and we would argue that this is a correct and/or pragmatic design choice in the circumstances. 
				</p>
				<h5><a name="sgt-event" class="anchor" href="#sgt-event"></a>The Event and Action classes</h5>
				<p>
					The event processing interface in SmartGridToolbox revolves around two classes: the <code><a href="doxygen_docs/class_sgt_1_1_event.html">Event</a></code> class, and the <code><a href="doxygen_docs/class_sgt_1_1_event.html">Action</a></code> class. These two classes are frequently used in simulations, for example to communicate that a change in one component should trigger an update in another.
				</p>
				<p>
					<code>Event</code> objects represent events that may be triggered. Each event holds a list of <code>Action</code> objects, that perform some arbitrary action when the event is triggered, in the form of a C++11 lambda.
				</p>
				<p>
					The following example shows how events and actions work together:
<script type="text/html" class="code">Event event("this is an event");
event.addAction([] () {std::cout << "beep!" << std::endl;});
event.trigger();
</script>
					which will cause "beep!" to be printed.
				</p>
				<h5><a name="sgt-prop" class="anchor" href="#sgt-prop"></a>Properties</h5>
				<p>
					It is often useful (for example, when writing a GUI) to have a more dynamic representation of the properties of an object than is provided by the C++ syntax. We would sometimes like to dynamically add properties to a class, and to dynamically get and set them, without first knowing what the set of properties is for an object.
				</p>
				<p>
					SmartGridToolbox defines a <code><a href="doxygen_docs/class_sgt_1_1_property.html">Property&ltT&gt</a></code> template class, that represents a property of type <code>T</code> (say, <code>int</code>, <code>double</code> or <code>arma::Col&ltComplex&gt</code>), that may be gotten and/or set. A non-template base class, <code><a href="doxygen_docs/class_sgt_1_1_property_base.html">PropertyBase</a></code>, provides a string-based interface for getting and setting properties when we don't know their type.
					For a class to implement properties, it should derive from the <code><a href="doxygen_docs/class_sgt_1_1_has_properties_interface.html">HasPropertiesInterface</a></code>, class.
				</p>
				<p>
					The following example, found in the <a href="properties_tutorial.html">properties tutorial</a>, shows properties in action:
<script type="text/html" class="code">#include <SgtCore/Properties.h>

class Foo : public Sgt::HasProperties<Foo>
{
    public:
        SGT_PROPS_INIT(Foo);                                                               

        int four() const {return 4;}
        SGT_PROP_GET(fourProp, Foo, int, four);
};

class Bar : public Foo, public Sgt::HasProperties<Bar>
{
    public:
        SGT_PROPS_INIT(Bar);                                                               
        SGT_PROPS_INHERIT(Bar, Foo);          

        const int& x() const {return x_;}
        void setX(const int& x) {x_ = x;}
        SGT_PROP_GET_SET(xProp, Bar, const int&, x, setX);

    public:
        int x_{5};
};
        

int main()
{
    Bar bar;
    for (auto& p : bar.properties())
    {
        std::cout << "Property " << p.first << " : " << p.second->string(bar) << std::endl;
    }
    Sgt::PropertyBase& xProp = *bar.properties()["xProp"];
    std::cout << "xProp as string : " << xProp.string(bar) << std::endl;
    std::cout << "xProp as const int& : " << xProp.get<const int&>(bar) << std::endl;
    xProp.set<const int&>(bar, 345);
    std::cout << "bar.x() should now be 345 : " << bar.x() << std::endl;
    xProp.setFromString(bar, "678");
    std::cout << "bar.x() should now be 678 : " << bar.x() << std::endl;
};</script>
				</p>
				<h4><a name="sgt-power-flow" class="anchor" href="#sgt-power-flow"></a>Power Flow Problems</h4>
				<p>
					Power Flow modelling and solution forms a key part of SmartGridToolbox. The overarching class used in modeling power flow problems is the <code><a href="doxygen_docs/class_sgt_1_1_network.html">Network</a></code> class.
				</p>
				<p>
					Network objects act as a container for network Components. There are four classes of network components: <code><a href="doxygen_docs/class_sgt_1_1_bus.html">Bus</a></code>ses, <code><a href="doxygen_docs/class_sgt_1_1_branch_abc.html">Branch</a></code>es, <code><a href="doxygen_docs/class_sgt_1_1_gen_abc.html">Gen</a></code>s and <code><a href="doxygen_docs/class_sgt_1_1_zip_abc.html">Zip</a></code>s.
				</p>
				<p>
					To understand how these components work together, the reader should first understand the classic power flow (or optimal power flow) problem, which is beyond the scope of this documentation. Briefly, though, busses are like conductor terminals: they are points or nodes in the network at which a single voltage exists. Branches are the lines, transformers and other connective components that join together busses. Gens (generators) normally represent generation of power, and act as injections of power from the ground to a bus. Zips are also power injections into a bus, but they normally represent network loads (consumption), and thus the injection is usually negative. They follow the commonly used ZIP (constant Z, I, P component) load model. The power flow problem revolves around finding the voltages and power injections at each bus so that the Kirchoff network laws and are satisfied while also satisfying requirements on the power injections and/or voltages.
				</p>
				<p>
					Network modelling and power flow solving is covered in the <a href="network_tutorial.html">network tutorial</a>. It starts with creating or parsing a <code>Network</code> object. <code>Network::solvePowerFlow</code> may then be called. Different solvers can be used by calling <code>Network::setSolver</code>; the default is to use the <a href="doxygen_docs/class_sgt_1_1_power_flow_nr_solver.html">Newton-Raphson AC power flow solver</a>, but an <a href="doxygen_docs/class_sgt_1_1_power_flow_pt_pp_solver.html">OPF solver</a> based on the PowerTools library is also available, and other solvers such as a DC power flow solver are planned.
				</p>
				<h4><a name="sgt-sim" class="anchor" href="#sgt-sim"></a>Simulations</h4>
				<p>
					The bread and butter of SmartGridToolbox is simulation. The <code><a href="doxygen_docs/class_sgt_1_1_simulation.html">Simulation</a></code> class is a container for simulation components, or <code><a href="doxygen_docs/class_sgt_1_1_sim_component.html">SimComponent</a></code>s, and is responsible for running the simulation and coordinating the time propagation and interaction between all of the components.
					A basic introduction to simulations can be found in the <a href="simulation_tutorial.html">simulation tutorial</a>. First, the user adds, or parses in, all of the <code><a href="doxygen_docs/class_sgt_1_1_sim_component.html">SimComponent</a></code>s and other simulation related information. <code>Simulation::init()</code> is then called, to initialize the simulation and all its components to the starting time, and to make sure that everything is valid. The simulation can then be progressed forward in time, typically by repeatedly calling <code>Simulation::doTimestep()</code> in a loop.
				</p>
				<h5><a name="sgt-sim" class="anchor" href="#sgt-sim-detailed"></a>A more detailed look at the simulation architecture</h5>
				<p>
					SmartGridToolbox simulations are event driven, meaning that there is no underlying timesteps; instead, all of the components of the simulation decide when they next need to update, and components may also trigger contingent updates on other components.
				</p>
				<p>
					At the start of a simulation, <code>initState()</code> is called for all components to make sure they are in a valid initial state.
				</p>
				<p>
					Before starting each new timestep, the <code>validUntil()</code> function is queried for components to decide when they would next like to update. The updates that are determined by this function are termed <em>scheduled updates</em>. (There is another kind of update, a <em>contingent update</em>, that is triggered by mutual interactions between components during a timestep; this will be discussed later).
				</p>
				<p>
					The soonest scheduled update time is chosen to form the next timestep. All components with a scheduled update at the selected time are updated, using the <code>updateState(Time t)</code> method, in order of dependency. If the update to A depends on the state of B but not vice-versa, then B will be updated first. Such dependencies help the simulation to avoid having to unnecessarily redo updates, but are not strictly necessary.
				</p>
				<p>
					At the end of each timestep, it may be the case that some components have not explicitly updated their state, since they did not request an update at the current time and were not asked to update by any dependent components during the timestep. This is normal behaviour.
				</p>
				<p>
					Each component can emit several <code>Event</code>s during the simulation cycle:
					<dl>
						<dt><code>willUpdate()</code></dt>
						<dd>Emitted directly prior to <code>updateState()</code>.</dd>
						<dt><code>didUpdate()</code></dt>
						<dd>Emitted directly after <code>updateState()</code>.</dd>
						<dt><code>needsUpdate()</code></dt>
						<dd>Signals that the component should update at some time during the current timestep, either via a scheduled update if it occurs first, or a contingent update (see below).
						</dd>
						<dt><code>willStartNewTimestep()</code></dt>
						<dd>Signals that the component is just about to update, and that its last update was prior to the current timestep.
						</dd>
						<dt><code>didCompleteTimestep()</code></dt>
						<dd>Signals that there are no more updates left in this timestep, and the component was one of the ones that updated this timestep.
						</dd>
					</dl>
				</p>
				<p>
					<code>needsUpdate()</code> is key to understanding contingent updates. Suppose, for example, that we have a network with a number of time varying loads. At their creation, these loads will register that they can push an update on the network object, through code that looks like, e.g. <code>load.injectionChanged().addAction([&network] () {network.needsUpdate().trigger();})</code>. Then, when their <code>injectionChanged()</code> event is triggered, the network's <code>needsUpdate()</code> event will also be triggered. This has a flow on effect that the simulation will schedule a contingent update for the network.
				</p>
				<p>
					However, this (and all other) contingent updates will be postponed until all the scheduled events have completed. This prevents the situation where a dependent component (i.e. the network) is repeatedly asked to update its state by multiple components (i.e. the loads); instead, each of the loads triggers the network's <code>needsUpdate</code> event, which is then executed once only, after all scheduled updates have finished.
				</p>
				<p>
					Also note that a contingent update may be pre-empted by a component (e.g. the network) itself undergoing a scheduled update, in which case the contingent update won't occur.
				</p>
				<h5><a name="sgt-simcomponents" class="anchor" href="#sgt-simcomponents"></a>The SimComponent class</h5>
				<p>
					In the discussions above, we have been referring to the <code><a href="doxygen_docs/class_sgt_1_1_sim_component.html">SimComponent</a></code> class as being the base class for all components of the simulation. This class derives from the <code><a href="doxygen_docs/class_sgt_1_1_component.html">Component</a></code> class, using public virtual inheritance. Thus, all SimComponents are Components, meaning that they have an id, component properties, can print themselves, and so on. To this, they add the behaviour discussed in the previous section: being able to initialize their state, update their state, and so on. Some of this functionality is handled using the (non-virtual interface) NVI idiom: the non-virtual public member functions <code>initialize()</code> and <code>update(Time t)</code> call protected virtual functions <code>initializeState()</code>, <code>updateState(Time t)</code>, and it is the latter that may be overridden if necessary when creating derived classes, along with the public virtual function <code>validUntil()</code>.
				</p>
				<div class="note">
					<h5><a name="sgt-mult" class="anchor" href="#sgt-mult"></a>A note about multiple inheritance, composition, etc.</h5>
					<p>
						The following discussion is mainly for those interested in software design issues, particularly as they apply to C++.
					<p>
						You may have noted that <code>SimComponent</code>, as well as non-simulation component classes such as <code>Bus</code>, have <code>Component</code> as a virtual base class. Similarly, all classes deriving from <code>SimComponent</code> use virtual inheritance. You may be aware that virtual inheritance is a mechanism used in C++ for dealing with the "dreaded diamond", where a base class is inherited via two possible pathways due to multiple inheritance. Virtual inheritance guarantees that only one copy of the base class ever exists in the hierarchy.
						
						Full-blown multiple inheritance is sometimes frowned upon in object-oriented circles, with various principles and idioms being used to circumvent it, such as <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">Composition Over Inheritance</a>, <a href="https://en.wikipedia.org/wiki/Mixin">Mixin Style</a> or only allowing abstract interfaces to be multiply inherited. <code><a href="doxygen_docs/class_sgt_1_1_sim_bus.html">SimBus</a></code>, <code><a href="doxygen_docs/class_sgt_1_1_sim_branch.html">SimBranch</a></code>, <code><a href="doxygen_docs/class_sgt_1_1_sim_gen.html">SimGen</a></code> and <code><a href="doxygen_docs/class_sgt_1_1_sim_zip.html">SimZip</a></code> are examples of more general classes that use composition instead of multiple inheritance, often a better design choice.
					</p>
					<p>
						There are only a couple of highly specialized classes in SmartGridToolbox where you will see multiple inheritance used - for example, <code><a href="doxygen_docs/class_sgt_1_1_simple_zip_inverter.html">SimpleZipInverter</a></code>. Although the inheritance diagram for this particular class is quite complicated, we feel we have made a good design choice in this case, for design and pragmatic reasons that have to do with the specifics of that particular case.
					</p>
					<p>
						One consequence of all this is that when inheriting from <code>Component</code> or <code>SimComponent</code>, it is best to use virtual inheritance. <code>SimComponent</code> has <code>Component</code> as a virtual base. Note that this has consequences for the order of initialization during construction. Briefly, a class with a virtual base (e.g. <code>Component</code>) should initialize the virtual base. Any initializations of that base that take place further up the inheritance hierarchy will be ignored. So in the hierarchy above, <code>Component</code> is <a href="doxygen_docs/_inverter_8h_source.html">initialized</a> by <code>SimpleZipInverter</code>.
					</p>
				</div>
				<h5><a name="sgt-simnetwork" class="anchor" href="#sgt-simnetwork"></a>The SimNetwork class</h5>
				<p>
					As discussed above, there exists in SmartGridToolbox a non-simulation-based framework for network modelling and solving. In simulations, this framework is used by wrapping non-simulation-based <code><a href="doxygen_docs/class_sgt_1_1_network.html">Network</a></code>s in simulation-based <code><a href="doxygen_docs/class_sgt_1_1_network.html">SimNetwork</a></code>s, by wrapping, for example, <code><a href="doxygen_docs/class_sgt_1_1_branch_abc.html">Branch</a></code> objects in <code><a href="doxygen_docs/class_sgt_1_1_sim_branch.html">SimBranch</a></code>es, and so on. Composition is used, meaning that <code>SimNetwork</code>s have an associated <code>Network</code>, <code>SimBranch</code>es have an associated <code>BranchAbc</code>, and so on.
				</p>
			</section> 
		</div>
		<script src="scripts/embed_code.js"></script>
		<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
	</body>
</html>
